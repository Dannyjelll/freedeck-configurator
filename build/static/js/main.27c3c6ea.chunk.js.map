{"version":3,"sources":["components/ImagePreview.tsx","lib/copyToClipboard.ts","App.tsx","index.tsx","definitions/headers.ts","lib/convertFile.ts","lib/bwConversion.ts","lib/bufferToHexString.ts","lib/uint8ToBase64.ts"],"names":["fileReader","Wrapper","styled","div","ControlRow","ControlRowMax","Label","label","FixedLabel","Button","button","CheckBox","input","PixelatedImage","img","handleFileSelect","file","Promise","resolve","reject","FileReader","onloadend","content","result","byteLength","readAsArrayBuffer","React","memo","image","useState","hexVal","setHexVal","contrast","setContrast","dither","setDither","invert","setInvert","b64Image","setB64Image","useEffect","a","arrayBuffer","convertFile","imageString","base64","hex","height","width","src","onClick","str","el","document","createElement","value","body","appendChild","select","execCommand","removeChild","copyToClipboard","title","Math","max","toFixed","min","htmlFor","id","type","onChange","checked","Main","App","images","setImages","onSubmit","event","preventDefault","target","files","length","map","index","key","name","ReactDOM","render","getElementById","bmp","imageArrayBuffer","pngImage","PNG","Jimp","read","Buffer","from","jimpImage","autocrop","scaleToFit","getBufferAsync","jimpPNG","parse","err","data","fs","buffer","sync","write","background","composite","getWidth","getHeight","converted","bwConversion","hexConverted","bitConversion","rgba","slice","encode","rgb","newArrayRGBA","newArrayRGB","i","j","values","intToRGBA","getPixelColor","bw","r","g","b","push","canvasWidth","output_string","output_index","byteIndex","number","pow","byteSet","toString","chr1","chr2","chr3","enc1","enc2","enc3","enc4","keyStr","output","Number","NaN","isNaN","charAt"],"mappings":"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","file":"static/js/main.27c3c6ea.chunk.js","sourcesContent":["import React, { useState, useEffect } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { copyToClipboard } from \"../lib/copyToClipboard\";\r\nimport { convertFile } from \"../lib/convertFile\";\r\n\r\nlet fileReader: FileReader;\r\nconst Wrapper = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  width: 300px;\r\n`;\r\n\r\nconst ControlRow = styled.div`\r\n  margin: 4px;\r\n  color: white;\r\n  display: flex;\r\n  align-items: center;\r\n`;\r\n\r\nconst ControlRowMax = styled.div`\r\n  margin: 4px;\r\n  color: white;\r\n  display: flex;\r\n  align-items: center;\r\n  width: 100%;\r\n  justify-content: space-between;\r\n`;\r\n\r\nconst Label = styled.label`\r\n  font-family: mono-space, sans-serif;\r\n  font-size: 18px;\r\n  font-weight: 500;\r\n  letter-spacing: 3px;\r\n`;\r\n\r\nconst FixedLabel = styled.div`\r\n  width: 75px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n`;\r\n\r\nconst Button = styled.button`\r\n  color: black;\r\n  background-color: white;\r\n  border: none;\r\n  width: 50px;\r\n  height 30px;\r\n  margin: 4px;\r\n  border-radius: 3px;\r\n`;\r\n\r\nconst CheckBox = styled.input`\r\n  width: 18px;\r\n  height: 18px;\r\n`;\r\n\r\nconst PixelatedImage = styled.img`\r\n  border: 1px solid white;\r\n  image-rendering: pixelated;\r\n  :hover {\r\n    cursor: pointer;\r\n  }\r\n`;\r\n\r\nconst handleFileSelect = (file: File): Promise<ArrayBuffer> => {\r\n  return new Promise((resolve, reject) => {\r\n    if (!file) return;\r\n    fileReader = new FileReader();\r\n    fileReader.onloadend = () => {\r\n      const content = fileReader.result as ArrayBuffer;\r\n      if (!content?.byteLength) return;\r\n      resolve(content as ArrayBuffer);\r\n    };\r\n    fileReader.readAsArrayBuffer(file);\r\n  });\r\n};\r\n\r\nconst ImagePreview: React.FC<{ image: File }> = ({ image }) => {\r\n  const [hexVal, setHexVal] = useState<string>(\"\");\r\n  const [contrast, setContrast] = useState<number>(0);\r\n  const [dither, setDither] = useState<boolean>(true);\r\n  const [invert, setInvert] = useState<boolean>(false);\r\n  const [b64Image, setB64Image] = useState<string>(\"\");\r\n  useEffect(() => {\r\n    (async () => {\r\n      const arrayBuffer = await handleFileSelect(image);\r\n      const imageString = await convertFile(\r\n        arrayBuffer,\r\n        contrast,\r\n        invert,\r\n        dither\r\n      );\r\n      setB64Image(imageString.base64);\r\n      setHexVal(imageString.hex);\r\n    })();\r\n  }, [contrast, dither, invert, image]);\r\n  return (\r\n    <Wrapper>\r\n      <PixelatedImage\r\n        height=\"150\"\r\n        width=\"300\"\r\n        src={b64Image}\r\n        onClick={() => copyToClipboard(hexVal)}\r\n        title=\"click to copy hex\"\r\n      />\r\n      <ControlRow>\r\n        <Button onClick={() => setContrast(Math.max(contrast - 0.1, -1))}>\r\n          - -\r\n        </Button>\r\n        <Button onClick={() => setContrast(Math.max(contrast - 0.02, -1))}>\r\n          -\r\n        </Button>\r\n        <FixedLabel>\r\n          <Label>{contrast.toFixed(2)}</Label>\r\n        </FixedLabel>\r\n        <Button onClick={() => setContrast(Math.min(contrast + 0.02, 1))}>\r\n          +\r\n        </Button>\r\n        <Button onClick={() => setContrast(Math.min(contrast + 0.1, 1))}>\r\n          + +\r\n        </Button>\r\n      </ControlRow>\r\n      <ControlRowMax>\r\n        <Label htmlFor=\"invert\">Invert</Label>\r\n        <CheckBox\r\n          id=\"invert\"\r\n          type=\"checkbox\"\r\n          onChange={() => setInvert(!invert)}\r\n          checked={invert}\r\n        />\r\n      </ControlRowMax>\r\n      <ControlRowMax>\r\n        <Label htmlFor=\"dither\">Dither</Label>\r\n        <CheckBox\r\n          id=\"dither\"\r\n          type=\"checkbox\"\r\n          onChange={() => setDither(!dither)}\r\n          checked={dither}\r\n        />\r\n      </ControlRowMax>\r\n    </Wrapper>\r\n  );\r\n};\r\n\r\nexport default React.memo(ImagePreview);\r\n","export const copyToClipboard = (str: string) => {\r\n  const el = document.createElement(\"textarea\");\r\n  el.value = str;\r\n  document.body.appendChild(el);\r\n  el.select();\r\n  document.execCommand(\"copy\");\r\n  document.body.removeChild(el);\r\n};\r\n","import React, { useState } from \"react\";\nimport styled from \"styled-components\";\nimport ImagePreview from \"./components/ImagePreview\";\n\nconst Main = styled.div`\n  background-color: black;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n`;\n\nfunction App() {\n  const [images, setImages] = useState<File[]>([]);\n\n  return (\n    <Main>\n      <form\n        onSubmit={event => {\n          event.preventDefault();\n        }}\n      >\n        <input\n          type=\"file\"\n          onChange={async event => {\n            if (event.target.files?.length) {\n              setImages([...images, event.target.files[0]]);\n            }\n          }}\n        ></input>\n      </form>\n      {images.map((image, index) => (\n        <ImagePreview key={image.name + index} image={image}></ImagePreview>\n      ))}\n    </Main>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n","export const bmp = [\r\n  66,\r\n  77,\r\n  54,\r\n  96,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  54,\r\n  0,\r\n  0,\r\n  0,\r\n  40,\r\n  0,\r\n  0,\r\n  0,\r\n  128,\r\n  0,\r\n  0,\r\n  0,\r\n  192,\r\n  255,\r\n  255,\r\n  255,\r\n  1,\r\n  0,\r\n  24,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  96,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0\r\n];\r\n","import { PNG } from \"pngjs\";\r\nimport Jimp from \"jimp\";\r\nimport fs from \"floyd-steinberg\";\r\nimport { bwConversion } from \"./bwConversion\";\r\nimport { bitConversion } from \"./bufferToHexString\";\r\nimport { encode } from \"./uint8ToBase64\";\r\n\r\nexport const convertFile = (\r\n  imageArrayBuffer: ArrayBuffer,\r\n  contrast: number,\r\n  invert: boolean,\r\n  dither: boolean\r\n): Promise<{ base64: string; hex: string }> => {\r\n  return new Promise(async resolve => {\r\n    const pngImage = new PNG();\r\n    const jimpImage = await Jimp.read(Buffer.from(imageArrayBuffer));\r\n    if (invert) jimpImage.invert();\r\n    await jimpImage.contrast(contrast);\r\n    jimpImage.autocrop().scaleToFit(128, 64);\r\n    const jimpPNG = await jimpImage.getBufferAsync(\"image/png\");\r\n\r\n    pngImage.parse(jimpPNG, async (err, data) => {\r\n      if (dither) data = fs(data);\r\n      const buffer = PNG.sync.write(data);\r\n      const jimpImage = await Jimp.read(buffer);\r\n      const background = new Jimp(128, 64, \"black\");\r\n      background.composite(\r\n        jimpImage,\r\n        64 - jimpImage.getWidth() / 2,\r\n        32 - jimpImage.getHeight() / 2\r\n      );\r\n      const converted = bwConversion(background);\r\n      // slice removes bitmap header\r\n      const hexConverted = bitConversion(converted.rgba.slice(55), 128);\r\n      resolve({\r\n        base64: \"data:image/bmp;base64,\" + encode(converted.rgb),\r\n        hex: hexConverted\r\n      });\r\n    });\r\n  });\r\n};\r\n","import Jimp from \"jimp\";\r\nimport { bmp } from \"../definitions/headers\";\r\n\r\nexport const bwConversion = (image: Jimp) => {\r\n  const newArrayRGBA: number[] = [...bmp];\r\n  const newArrayRGB: number[] = [...bmp];\r\n  for (var i = 0; i < 64; i++) {\r\n    for (var j = 0; j < 128; j++) {\r\n      const values = Jimp.intToRGBA(image.getPixelColor(j, i));\r\n      const bw = (values.r + values.g + values.b) / 3 > 128 ? 255 : 0;\r\n      newArrayRGBA.push(bw);\r\n      newArrayRGBA.push(bw);\r\n      newArrayRGBA.push(bw);\r\n      newArrayRGBA.push(bw);\r\n      newArrayRGB.push(bw);\r\n      newArrayRGB.push(bw);\r\n      newArrayRGB.push(bw);\r\n    }\r\n  }\r\n  return { rgba: Buffer.from(newArrayRGBA), rgb: Buffer.from(newArrayRGB) };\r\n};\r\n","export const bitConversion = (data: Buffer, canvasWidth: number) => {\r\n  var output_string = \"\";\r\n  var output_index = 0;\r\n\r\n  var byteIndex = 7;\r\n  var number = 0;\r\n\r\n  // format is RGBA, so move 4 steps per pixel\r\n  for (var index = 0; index < data.length; index += 4) {\r\n    // Get the average of the RGB (we ignore A)\r\n    var avg = (data[index] + data[index + 1] + data[index + 2]) / 3;\r\n    if (avg > 128) {\r\n      number += Math.pow(2, byteIndex);\r\n    }\r\n    byteIndex--;\r\n    // if this was the last pixel of a row or the last pixel of the\r\n    // image, fill up the rest of our byte with zeros so it always contains 8 bits\r\n    if (\r\n      (index !== 0 && (index / 4 + 1) % canvasWidth === 0) ||\r\n      index === data.length - 4\r\n    ) {\r\n      for (var i = byteIndex; i > -1; i--) {\r\n        number += Math.pow(2, i);\r\n      }\r\n      byteIndex = -1;\r\n    }\r\n\r\n    // When we have the complete 8 bits, combine them into a hex value\r\n    if (byteIndex < 0) {\r\n      var byteSet = number.toString(16);\r\n      if (byteSet.length === 1) {\r\n        byteSet = \"0\" + byteSet;\r\n      }\r\n      var hex = \"0x\" + byteSet;\r\n      output_string += hex + \", \";\r\n      output_index++;\r\n      if (output_index >= 16) {\r\n        output_string += \"\\n\";\r\n        output_index = 0;\r\n      }\r\n      number = 0;\r\n      byteIndex = 7;\r\n    }\r\n  }\r\n  return output_string;\r\n};\r\n","export const encode = (input: Uint8Array) => {\r\n  var keyStr =\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n  var output = \"\";\r\n  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n  var i = 0;\r\n\r\n  while (i < input.length) {\r\n    chr1 = input[i++];\r\n    chr2 = i < input.length ? input[i++] : Number.NaN; // Not sure if the index\r\n    chr3 = i < input.length ? input[i++] : Number.NaN; // checks are needed here\r\n\r\n    enc1 = chr1 >> 2;\r\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n    enc4 = chr3 & 63;\r\n\r\n    if (isNaN(chr2)) {\r\n      enc3 = enc4 = 64;\r\n    } else if (isNaN(chr3)) {\r\n      enc4 = 64;\r\n    }\r\n    output +=\r\n      keyStr.charAt(enc1) +\r\n      keyStr.charAt(enc2) +\r\n      keyStr.charAt(enc3) +\r\n      keyStr.charAt(enc4);\r\n  }\r\n  return output;\r\n};\r\n"],"sourceRoot":""}